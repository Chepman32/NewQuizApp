// Japanese translations for Data Structures questions
// データ構造問題の日本語翻訳

import type { CategoryTranslations } from '../index';

export const dataStructures: CategoryTranslations = {
  // ===== レベル1-2: とても簡単/簡単 =====
  ds1: {
    text: '配列とは何ですか？',
    correct: '同じ型の要素の連続した集合',
    wrong: ['異なる型の要素の集合', 'ランダムな要素の集合', '単一の要素'],
  },
  ds2: {
    text: '配列のインデックスは何から始まる？',
    correct: '0（多くの言語で）',
    wrong: ['1', '-1', '任意の数'],
  },
  ds3: {
    text: '配列の要素へのアクセス時間は？',
    correct: 'O(1)',
    wrong: ['O(n)', 'O(log n)', 'O(n²)'],
  },
  ds4: {
    text: '連結リストとは何ですか？',
    correct: 'ノードがポインタで連結されたデータ構造',
    wrong: ['配列の一種', 'ツリーの一種', 'グラフの一種'],
  },
  ds5: {
    text: '単方向連結リストの特徴は？',
    correct: '次のノードへのポインタのみ',
    wrong: ['前後のノードへのポインタ', 'ポインタなし', '全ノードへのポインタ'],
  },
  ds6: {
    text: '双方向連結リストの特徴は？',
    correct: '前後のノードへのポインタ',
    wrong: [
      '次のノードへのポインタのみ',
      'ポインタなし',
      '全ノードへのポインタ',
    ],
  },
  ds7: {
    text: '連結リストの先頭への挿入時間は？',
    correct: 'O(1)',
    wrong: ['O(n)', 'O(log n)', 'O(n²)'],
  },
  ds8: {
    text: '連結リストの検索時間は？',
    correct: 'O(n)',
    wrong: ['O(1)', 'O(log n)', 'O(n²)'],
  },
  ds9: {
    text: 'スタックとは何ですか？',
    correct: 'LIFO（後入れ先出し）のデータ構造',
    wrong: ['FIFO', 'ランダムアクセス', '優先度付き'],
  },
  ds10: {
    text: 'スタックの主な操作は？',
    correct: 'push（追加）とpop（削除）',
    wrong: ['enqueue と dequeue', 'insert と delete', 'add と remove'],
  },
  ds11: {
    text: 'キューとは何ですか？',
    correct: 'FIFO（先入れ先出し）のデータ構造',
    wrong: ['LIFO', 'ランダムアクセス', '優先度付き'],
  },
  ds12: {
    text: 'キューの主な操作は？',
    correct: 'enqueue（追加）とdequeue（削除）',
    wrong: ['push と pop', 'insert と delete', 'add と remove'],
  },
  ds13: {
    text: 'スタックの使用例は？',
    correct: '関数呼び出し、括弧の対応確認',
    wrong: ['プリンタキュー', 'ファイルシステム', 'データベース'],
  },
  ds14: {
    text: 'キューの使用例は？',
    correct: 'プリンタキュー、タスクスケジューリング',
    wrong: ['関数呼び出し', '括弧の対応確認', '再帰'],
  },
  ds15: {
    text: 'ハッシュテーブルとは何ですか？',
    correct: 'キーと値のペアを格納するデータ構造',
    wrong: ['配列の一種', '連結リストの一種', 'ツリーの一種'],
  },
  ds16: {
    text: 'ハッシュ関数の役割は？',
    correct: 'キーをインデックスに変換',
    wrong: ['データを暗号化', 'データを圧縮', 'データをソート'],
  },
  ds17: {
    text: 'ハッシュテーブルの平均検索時間は？',
    correct: 'O(1)',
    wrong: ['O(n)', 'O(log n)', 'O(n²)'],
  },
  ds18: {
    text: 'ハッシュ衝突とは何ですか？',
    correct: '異なるキーが同じインデックスになる',
    wrong: [
      '同じキーが異なるインデックスになる',
      'キーが見つからない',
      'テーブルが満杯',
    ],
  },
  ds19: {
    text: '木構造とは何ですか？',
    correct: '階層的なデータ構造',
    wrong: ['線形なデータ構造', '循環的なデータ構造', 'ランダムなデータ構造'],
  },
  ds20: {
    text: '木の根とは何ですか？',
    correct: '最上位のノード',
    wrong: ['最下位のノード', '中間のノード', '任意のノード'],
  },
  ds21: {
    text: '木の葉とは何ですか？',
    correct: '子を持たないノード',
    wrong: ['根のノード', '子を持つノード', '親を持たないノード'],
  },
  ds22: {
    text: '二分木とは何ですか？',
    correct: '各ノードが最大2つの子を持つ木',
    wrong: [
      '各ノードが3つの子を持つ木',
      '各ノードが1つの子を持つ木',
      '子の数に制限がない木',
    ],
  },
  ds23: {
    text: '二分探索木の特徴は？',
    correct: '左の子 < 親 < 右の子',
    wrong: ['左の子 > 親 > 右の子', '順序なし', 'ランダム'],
  },
  ds24: {
    text: '二分探索木の平均検索時間は？',
    correct: 'O(log n)',
    wrong: ['O(1)', 'O(n)', 'O(n²)'],
  },
  ds25: {
    text: 'グラフとは何ですか？',
    correct: '頂点と辺からなるデータ構造',
    wrong: ['木の一種', '配列の一種', '連結リストの一種'],
  },

  // ===== レベル3-4: 中級/普通 =====
  ds26: {
    text: '有向グラフとは？',
    correct: '辺に方向があるグラフ',
    wrong: ['辺に方向がないグラフ', '重みがあるグラフ', '循環がないグラフ'],
  },
  ds27: {
    text: '無向グラフとは？',
    correct: '辺に方向がないグラフ',
    wrong: ['辺に方向があるグラフ', '重みがあるグラフ', '循環がないグラフ'],
  },
  ds28: {
    text: '重み付きグラフとは？',
    correct: '辺に重みがあるグラフ',
    wrong: ['辺に方向があるグラフ', '辺に方向がないグラフ', '循環がないグラフ'],
  },
  ds29: {
    text: '隣接行列とは？',
    correct: 'グラフを2次元配列で表現',
    wrong: [
      'グラフをリストで表現',
      'グラフを木で表現',
      'グラフをスタックで表現',
    ],
  },
  ds30: {
    text: '隣接リストとは？',
    correct: 'グラフをリストの配列で表現',
    wrong: [
      'グラフを2次元配列で表現',
      'グラフを木で表現',
      'グラフをスタックで表現',
    ],
  },
  ds31: {
    text: 'ヒープとは何ですか？',
    correct: '親が子より大きい（または小さい）完全二分木',
    wrong: ['二分探索木', '平衡木', 'B木'],
  },
  ds32: {
    text: '最大ヒープの特徴は？',
    correct: '親が子より大きい',
    wrong: ['親が子より小さい', '左の子が右の子より大きい', '順序なし'],
  },
  ds33: {
    text: '最小ヒープの特徴は？',
    correct: '親が子より小さい',
    wrong: ['親が子より大きい', '左の子が右の子より小さい', '順序なし'],
  },
  ds34: {
    text: 'ヒープの挿入時間は？',
    correct: 'O(log n)',
    wrong: ['O(1)', 'O(n)', 'O(n²)'],
  },
  ds35: {
    text: 'ヒープの最大（最小）値取得時間は？',
    correct: 'O(1)',
    wrong: ['O(log n)', 'O(n)', 'O(n²)'],
  },
  ds36: {
    text: '優先度キューとは？',
    correct: '優先度に基づいて要素を取り出すキュー',
    wrong: ['FIFOキュー', 'LIFOキュー', 'ランダムキュー'],
  },
  ds37: {
    text: '優先度キューの実装に適したデータ構造は？',
    correct: 'ヒープ',
    wrong: ['配列', '連結リスト', 'スタック'],
  },
  ds38: {
    text: 'AVL木とは？',
    correct: '高さが平衡な二分探索木',
    wrong: ['不平衡な二分探索木', 'B木', '赤黒木'],
  },
  ds39: {
    text: 'AVL木の平衡条件は？',
    correct: '左右の部分木の高さの差が1以下',
    wrong: ['高さの差が2以下', '高さの差が0', '高さの差に制限なし'],
  },
  ds40: {
    text: '赤黒木とは？',
    correct: '色で平衡を保つ二分探索木',
    wrong: ['AVL木', 'B木', 'トライ'],
  },
  ds41: {
    text: 'B木とは？',
    correct: '多分岐の平衡探索木',
    wrong: ['二分探索木', 'AVL木', '赤黒木'],
  },
  ds42: {
    text: 'B木の主な用途は？',
    correct: 'データベースのインデックス',
    wrong: ['メモリ管理', 'ネットワーク', 'グラフィック'],
  },
  ds43: {
    text: 'トライとは？',
    correct: '文字列を格納する木構造',
    wrong: ['数値を格納する木', 'グラフの一種', 'ヒープの一種'],
  },
  ds44: {
    text: 'トライの検索時間は？',
    correct: 'O(m) mは文字列の長さ',
    wrong: ['O(n)', 'O(log n)', 'O(n²)'],
  },
  ds45: {
    text: 'セグメント木とは？',
    correct: '範囲クエリを効率的に処理する木',
    wrong: ['二分探索木', 'AVL木', 'B木'],
  },
  ds46: {
    text: 'セグメント木の構築時間は？',
    correct: 'O(n)',
    wrong: ['O(log n)', 'O(n log n)', 'O(n²)'],
  },
  ds47: {
    text: 'セグメント木のクエリ時間は？',
    correct: 'O(log n)',
    wrong: ['O(1)', 'O(n)', 'O(n²)'],
  },
  ds48: {
    text: 'フェニック木（BIT）とは？',
    correct: '接頭辞和を効率的に計算する木',
    wrong: ['二分探索木', 'AVL木', 'B木'],
  },
  ds49: {
    text: 'Union-Findとは？',
    correct: '素集合を管理するデータ構造',
    wrong: ['ソートアルゴリズム', '検索アルゴリズム', 'グラフアルゴリズム'],
  },
  ds50: {
    text: 'Union-Findの主な操作は？',
    correct: 'union（結合）とfind（検索）',
    wrong: ['push と pop', 'enqueue と dequeue', 'insert と delete'],
  },

  // ===== レベル5-6: 難しい/とても難しい =====
  ds51: {
    text: '経路圧縮とは？',
    correct: 'Union-Findで木を平坦化する最適化',
    wrong: ['データを圧縮', 'ファイルを圧縮', 'ネットワークを圧縮'],
  },
  ds52: {
    text: 'ランクによる結合とは？',
    correct: 'Union-Findで小さい木を大きい木に結合',
    wrong: ['ランダムに結合', '常に左に結合', '常に右に結合'],
  },
  ds53: {
    text: 'スキップリストとは？',
    correct: '複数レベルの連結リスト',
    wrong: ['単一レベルの連結リスト', '配列', 'ツリー'],
  },
  ds54: {
    text: 'スキップリストの平均検索時間は？',
    correct: 'O(log n)',
    wrong: ['O(1)', 'O(n)', 'O(n²)'],
  },
  ds55: {
    text: 'ブルームフィルタとは？',
    correct: '確率的なメンバーシップテスト',
    wrong: [
      '正確なメンバーシップテスト',
      'ソートアルゴリズム',
      '検索アルゴリズム',
    ],
  },
  ds56: {
    text: 'ブルームフィルタの特徴は？',
    correct: '偽陽性はあるが偽陰性はない',
    wrong: ['偽陰性はあるが偽陽性はない', '両方ある', '両方ない'],
  },
  ds57: {
    text: 'LRUキャッシュとは？',
    correct: '最も最近使われていない要素を削除',
    wrong: ['最も最近使われた要素を削除', 'ランダムに削除', '最初の要素を削除'],
  },
  ds58: {
    text: 'LRUキャッシュの実装に適した構造は？',
    correct: 'ハッシュマップと双方向連結リスト',
    wrong: ['配列のみ', 'スタックのみ', 'キューのみ'],
  },
  ds59: {
    text: '永続データ構造とは？',
    correct: '変更後も以前のバージョンにアクセス可能',
    wrong: [
      '変更後は以前のバージョンにアクセス不可',
      'ディスクに保存',
      'メモリに保存',
    ],
  },
  ds60: {
    text: 'イミュータブルデータ構造とは？',
    correct: '変更不可能なデータ構造',
    wrong: ['変更可能なデータ構造', '一時的なデータ構造', '永続的なデータ構造'],
  },
  ds61: {
    text: 'ロープとは？',
    correct: '長い文字列を効率的に扱う木構造',
    wrong: ['短い文字列用', '数値用', 'グラフ用'],
  },
  ds62: {
    text: 'サフィックス配列とは？',
    correct: '文字列の全接尾辞をソートした配列',
    wrong: ['接頭辞の配列', '部分文字列の配列', '文字の配列'],
  },
  ds63: {
    text: 'サフィックス木とは？',
    correct: '文字列の全接尾辞を格納する木',
    wrong: ['接頭辞を格納する木', '部分文字列を格納する木', '文字を格納する木'],
  },
  ds64: {
    text: 'サフィックス木の構築時間は？',
    correct: 'O(n)',
    wrong: ['O(n log n)', 'O(n²)', 'O(log n)'],
  },
  ds65: {
    text: 'K-D木とは？',
    correct: 'K次元空間の点を格納する木',
    wrong: ['1次元の木', '2次元の木のみ', 'グラフ'],
  },
  ds66: {
    text: 'K-D木の主な用途は？',
    correct: '最近傍探索',
    wrong: ['ソート', '文字列検索', 'グラフ探索'],
  },
  ds67: {
    text: 'R木とは？',
    correct: '空間データを格納する木',
    wrong: ['文字列を格納する木', '数値を格納する木', 'グラフを格納する木'],
  },
  ds68: {
    text: 'クアッドツリーとは？',
    correct: '2次元空間を4分割する木',
    wrong: ['2分割する木', '8分割する木', '分割しない木'],
  },
  ds69: {
    text: 'オクツリーとは？',
    correct: '3次元空間を8分割する木',
    wrong: ['4分割する木', '2分割する木', '分割しない木'],
  },
  ds70: {
    text: 'インターバル木とは？',
    correct: '区間を格納する木',
    wrong: ['点を格納する木', '文字列を格納する木', 'グラフを格納する木'],
  },
  ds71: {
    text: 'マージソート木とは？',
    correct: 'マージソートの過程を木で表現',
    wrong: ['クイックソートの木', 'ヒープソートの木', 'バブルソートの木'],
  },
  ds72: {
    text: 'ウェーブレット木とは？',
    correct: '文字列のランク/セレクトクエリ用の木',
    wrong: ['数値用の木', 'グラフ用の木', '画像用の木'],
  },
  ds73: {
    text: 'ファンアウトとは？',
    correct: 'ノードの子の数',
    wrong: ['ノードの親の数', 'ノードの深さ', 'ノードの高さ'],
  },
  ds74: {
    text: 'B+木とは？',
    correct: '葉にのみデータを格納するB木',
    wrong: ['全ノードにデータを格納', 'B木と同じ', 'AVL木の一種'],
  },
  ds75: {
    text: 'B+木の利点は？',
    correct: '範囲検索が効率的',
    wrong: ['点検索が効率的', 'メモリ使用量が少ない', '構築が速い'],
  },

  // ===== レベル7-8: 伝説/教授 =====
  ds76: {
    text: 'スプレー木とは？',
    correct: 'アクセスしたノードを根に移動する木',
    wrong: ['AVL木', '赤黒木', 'B木'],
  },
  ds77: {
    text: 'スプレー木の償却計算量は？',
    correct: 'O(log n)',
    wrong: ['O(1)', 'O(n)', 'O(n²)'],
  },
  ds78: {
    text: 'トレープとは？',
    correct: '木とヒープの性質を持つデータ構造',
    wrong: ['木のみ', 'ヒープのみ', 'グラフ'],
  },
  ds79: {
    text: 'フィボナッチヒープとは？',
    correct: '償却計算量が優れたヒープ',
    wrong: ['二分ヒープ', '三分ヒープ', 'B木'],
  },
  ds80: {
    text: 'フィボナッチヒープの挿入の償却計算量は？',
    correct: 'O(1)',
    wrong: ['O(log n)', 'O(n)', 'O(n²)'],
  },
  ds81: {
    text: 'ペアリングヒープとは？',
    correct: '実装が簡単で効率的なヒープ',
    wrong: ['二分ヒープ', 'フィボナッチヒープ', 'B木'],
  },
  ds82: {
    text: 'ヴァンエムデボーアス木とは？',
    correct: '整数を効率的に格納する木',
    wrong: ['文字列用の木', '浮動小数点用の木', 'グラフ用の木'],
  },
  ds83: {
    text: 'ヴァンエムデボーアス木の操作時間は？',
    correct: 'O(log log U)',
    wrong: ['O(log n)', 'O(n)', 'O(1)'],
  },
  ds84: {
    text: 'リンクカット木とは？',
    correct: '動的な木の連結と切断を行う',
    wrong: ['静的な木', '連結リスト', 'グラフ'],
  },
  ds85: {
    text: 'オイラーツアー木とは？',
    correct: '木をオイラーツアーで表現',
    wrong: ['二分探索木', 'AVL木', 'B木'],
  },
  ds86: {
    text: 'ヘビーライト分解とは？',
    correct: '木をチェーンに分解する技法',
    wrong: ['木を配列に変換', '木をグラフに変換', '木を削除'],
  },
  ds87: {
    text: 'センタロイド分解とは？',
    correct: '木を重心で再帰的に分割',
    wrong: ['木を根で分割', '木を葉で分割', '木を分割しない'],
  },
  ds88: {
    text: 'モーのアルゴリズムに適したデータ構造は？',
    correct: '平方分割',
    wrong: ['セグメント木', 'フェニック木', 'AVL木'],
  },
  ds89: {
    text: '永続セグメント木とは？',
    correct: '過去のバージョンにアクセス可能なセグメント木',
    wrong: ['通常のセグメント木', 'フェニック木', 'AVL木'],
  },
  ds90: {
    text: '遅延伝播とは？',
    correct: '更新を遅延させて効率化',
    wrong: ['即座に更新', '更新しない', 'ランダムに更新'],
  },
  ds91: {
    text: 'マージソート木の用途は？',
    correct: '範囲内のk番目の要素を求める',
    wrong: ['ソート', '検索', 'グラフ探索'],
  },
  ds92: {
    text: 'ウェーブレット行列とは？',
    correct: 'ウェーブレット木の配列実装',
    wrong: ['行列の一種', 'グラフの一種', 'ヒープの一種'],
  },
  ds93: {
    text: 'サクシンクトデータ構造とは？',
    correct: '情報理論的下限に近い空間効率',
    wrong: ['空間効率が悪い', '時間効率が悪い', '両方悪い'],
  },
  ds94: {
    text: 'ランクとセレクトとは？',
    correct: 'ビット列の基本操作',
    wrong: ['ソートの操作', '検索の操作', 'グラフの操作'],
  },
  ds95: {
    text: 'FM-indexとは？',
    correct: '圧縮された全文検索インデックス',
    wrong: ['非圧縮インデックス', 'グラフインデックス', '数値インデックス'],
  },
  ds96: {
    text: 'CSA（圧縮サフィックス配列）とは？',
    correct: '圧縮されたサフィックス配列',
    wrong: ['非圧縮サフィックス配列', 'サフィックス木', 'トライ'],
  },
  ds97: {
    text: 'ダイナミックコネクティビティとは？',
    correct: '動的なグラフの連結性クエリ',
    wrong: ['静的なグラフ', '木の連結性', '配列の連結性'],
  },
  ds98: {
    text: 'オフラインクエリとは？',
    correct: 'クエリを事前に知っている場合の処理',
    wrong: ['クエリを知らない場合', 'リアルタイム処理', 'ストリーム処理'],
  },
  ds99: {
    text: 'オンラインクエリとは？',
    correct: 'クエリが順次到着する場合の処理',
    wrong: ['クエリを事前に知っている場合', 'バッチ処理', 'オフライン処理'],
  },
  ds100: {
    text: 'アモルタイズド解析とは？',
    correct: '操作列の平均計算量を分析',
    wrong: ['最悪計算量を分析', '最良計算量を分析', '空間計算量を分析'],
  },
};

export default dataStructures;
