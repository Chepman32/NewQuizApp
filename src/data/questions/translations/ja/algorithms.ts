// Japanese translations for Algorithms questions
// アルゴリズム問題の日本語翻訳

import type { CategoryTranslations } from '../index';

export const algorithms: CategoryTranslations = {
  // ===== レベル1-2: とても簡単/簡単 =====
  alg1: {
    text: 'アルゴリズムとは何ですか？',
    correct: '問題を解決するための手順',
    wrong: ['プログラミング言語', 'データ構造', 'コンピュータハードウェア'],
  },
  alg2: {
    text: 'ソートとは何ですか？',
    correct: '要素を順序通りに並べること',
    wrong: ['要素を検索すること', '要素を削除すること', '要素を追加すること'],
  },
  alg3: {
    text: '検索とは何ですか？',
    correct: '要素を見つけること',
    wrong: ['要素をソートすること', '要素を削除すること', '要素を追加すること'],
  },
  alg4: {
    text: '線形検索とは何ですか？',
    correct: '各要素を一つずつ確認すること',
    wrong: ['二分探索', 'ハッシュ検索', '木探索'],
  },
  alg5: {
    text: '線形検索の時間計算量は？',
    correct: 'O(n)',
    wrong: ['O(1)', 'O(log n)', 'O(n²)'],
  },
  alg6: {
    text: '二分探索とは何ですか？',
    correct: 'ソート済み配列を半分に分割して検索',
    wrong: ['線形検索', 'ハッシュ検索', '木探索'],
  },
  alg7: {
    text: '二分探索の時間計算量は？',
    correct: 'O(log n)',
    wrong: ['O(n)', 'O(1)', 'O(n²)'],
  },
  alg8: {
    text: '二分探索に必要な条件は？',
    correct: 'ソート済み配列',
    wrong: ['未ソート配列', '連結リスト', '木構造'],
  },
  alg9: {
    text: 'バブルソートとは何ですか？',
    correct: '隣接要素を繰り返し交換する',
    wrong: ['分割統治法', 'ヒープを使用', 'ピボットを使用'],
  },
  alg10: {
    text: 'バブルソートの時間計算量は？',
    correct: 'O(n²)',
    wrong: ['O(n)', 'O(log n)', 'O(n log n)'],
  },
  alg11: {
    text: '選択ソートとは何ですか？',
    correct: '最小値を見つけて先頭に配置',
    wrong: ['隣接要素を交換', '配列を分割', 'ヒープを使用'],
  },
  alg12: {
    text: '挿入ソートとは何ですか？',
    correct: 'ソート済み部分に要素を挿入',
    wrong: ['隣接要素を交換', '最小値を見つける', 'ピボットを使用'],
  },
  alg13: {
    text: '挿入ソートの最良ケースは？',
    correct: 'O(n) - 既にソート済み',
    wrong: ['O(n²)', 'O(log n)', 'O(n log n)'],
  },
  alg14: {
    text: 'マージソートとは何ですか？',
    correct: '分割してソートしてマージ',
    wrong: ['隣接要素を交換', '最小値を見つける', 'ピボットを使用'],
  },
  alg15: {
    text: 'マージソートの時間計算量は？',
    correct: 'O(n log n)',
    wrong: ['O(n²)', 'O(n)', 'O(log n)'],
  },
  alg16: {
    text: 'クイックソートとは何ですか？',
    correct: 'ピボットを中心に分割',
    wrong: ['分割してマージ', '隣接要素を交換', '最小値を見つける'],
  },
  alg17: {
    text: 'クイックソートの平均時間計算量は？',
    correct: 'O(n log n)',
    wrong: ['O(n²)', 'O(n)', 'O(log n)'],
  },
  alg18: {
    text: 'クイックソートの最悪ケースは？',
    correct: 'O(n²) - 悪いピボット選択時',
    wrong: ['O(n log n)', 'O(n)', 'O(log n)'],
  },
  alg19: {
    text: 'ヒープソートとは何ですか？',
    correct: 'ヒープデータ構造を使用',
    wrong: ['ピボットを使用', 'マージ', '隣接要素を交換'],
  },
  alg20: {
    text: 'ヒープソートの時間計算量は？',
    correct: 'O(n log n)',
    wrong: ['O(n²)', 'O(n)', 'O(log n)'],
  },
  alg21: {
    text: '安定ソートアルゴリズムとは？',
    correct: '等しい要素の順序を保持',
    wrong: [
      '最速のアルゴリズム',
      'メモリ効率が良い',
      'インプレースアルゴリズム',
    ],
  },
  alg22: {
    text: 'マージソートは安定ですか？',
    correct: 'はい',
    wrong: ['いいえ', '時々', '実装による'],
  },
  alg23: {
    text: 'クイックソートは安定ですか？',
    correct: 'いいえ（通常）',
    wrong: ['はい', '常に', '決して'],
  },
  alg24: {
    text: 'インプレースソートとは？',
    correct: 'O(1)の追加空間でソート',
    wrong: ['O(n)の空間を使用', '安定ソート', '高速ソート'],
  },
  alg25: {
    text: 'マージソートはインプレースですか？',
    correct: 'いいえ - O(n)の追加空間が必要',
    wrong: ['はい', '時々', '場合による'],
  },

  // ===== レベル3-4: 中級/普通 =====
  alg26: {
    text: 'カウンティングソートとは？',
    correct: '各要素の出現回数をカウント',
    wrong: ['比較ソート', '分割統治法', 'ヒープを使用'],
  },
  alg27: {
    text: 'カウンティングソートの時間計算量は？',
    correct: 'O(n + k) kは範囲',
    wrong: ['O(n log n)', 'O(n²)', 'O(log n)'],
  },
  alg28: {
    text: '基数ソートとは何ですか？',
    correct: '桁ごとにソート',
    wrong: ['比較ソート', '分割統治法', 'ヒープを使用'],
  },
  alg29: {
    text: 'バケットソートとは何ですか？',
    correct: '要素をバケットに分配',
    wrong: ['比較ソート', '分割統治法', 'ヒープを使用'],
  },
  alg30: {
    text: '比較ソートの下限は？',
    correct: 'O(n log n)',
    wrong: ['O(n)', 'O(n²)', 'O(log n)'],
  },
  alg31: {
    text: '深さ優先探索（DFS）とは？',
    correct: '可能な限り深く探索してから戻る',
    wrong: ['レベルごとに探索', 'ランダム探索', '最短経路'],
  },
  alg32: {
    text: '幅優先探索（BFS）とは？',
    correct: 'レベルごとに探索',
    wrong: ['深さ優先で探索', 'ランダム探索', '最長経路'],
  },
  alg33: {
    text: 'DFSが通常使用するデータ構造は？',
    correct: 'スタック',
    wrong: ['キュー', 'ヒープ', '配列'],
  },
  alg34: {
    text: 'BFSが通常使用するデータ構造は？',
    correct: 'キュー',
    wrong: ['スタック', 'ヒープ', '配列'],
  },
  alg35: {
    text: 'DFSの時間計算量は？',
    correct: 'O(V + E)',
    wrong: ['O(V)', 'O(E)', 'O(V × E)'],
  },
  alg36: {
    text: 'BFSの時間計算量は？',
    correct: 'O(V + E)',
    wrong: ['O(V)', 'O(E)', 'O(V × E)'],
  },
  alg37: {
    text: 'ダイクストラ法とは？',
    correct: '単一始点最短経路を求める',
    wrong: ['最小全域木を求める', 'グラフをソート', 'サイクルを検出'],
  },
  alg38: {
    text: 'ベルマンフォード法とは？',
    correct: '負の辺がある最短経路',
    wrong: ['正の辺のみ', '最小全域木', 'トポロジカルソート'],
  },
  alg39: {
    text: 'フロイドワーシャル法とは？',
    correct: '全点対最短経路',
    wrong: ['単一始点最短経路', '最小全域木', 'サイクル検出'],
  },
  alg40: {
    text: 'クラスカル法とは？',
    correct: 'ソートした辺で最小全域木',
    wrong: ['最短経路', 'トポロジカルソート', 'サイクル検出'],
  },
  alg41: {
    text: 'プリム法とは？',
    correct: '頂点から成長する最小全域木',
    wrong: ['最短経路', 'トポロジカルソート', 'サイクル検出'],
  },
  alg42: {
    text: 'トポロジカルソートとは？',
    correct: 'DAGの頂点を順序付け',
    wrong: ['辺をソート', 'サイクルを見つける', '最短経路'],
  },
  alg43: {
    text: '動的計画法とは？',
    correct: '重複する部分問題を解く',
    wrong: ['分割統治法', '貪欲法', '総当たり'],
  },
  alg44: {
    text: 'メモ化とは？',
    correct: '部分問題の結果を保存',
    wrong: ['常に再計算', '再帰を使用', '反復を使用'],
  },
  alg45: {
    text: '動的計画法のタビュレーションとは？',
    correct: 'ボトムアップアプローチ',
    wrong: ['トップダウンアプローチ', '再帰', '総当たり'],
  },
  alg46: {
    text: '貪欲法とは？',
    correct: '各ステップで局所最適を選択',
    wrong: ['全ての選択肢を考慮', '動的計画法を使用', '総当たり'],
  },
  alg47: {
    text: '分割統治法とは？',
    correct: '問題を分割し、解いて、統合',
    wrong: ['順次解く', '動的計画法を使用', '貪欲法'],
  },
  alg48: {
    text: 'バックトラッキングとは？',
    correct: '解を試して失敗したら戻る',
    wrong: ['戻らない', '貪欲法', '動的計画法'],
  },
  alg49: {
    text: 'ナップサック問題とは？',
    correct: '容量制限内で価値を最大化',
    wrong: ['重さを最小化', '要素をソート', '要素を検索'],
  },
  alg50: {
    text: '最長共通部分列（LCS）とは？',
    correct: '最長の共通部分列を見つける',
    wrong: ['部分文字列を見つける', '文字列をソート', 'パターンを検索'],
  },

  // ===== レベル5-6: 難しい/とても難しい =====
  alg51: {
    text: '編集距離問題とは？',
    correct: '文字列変換の最小操作数',
    wrong: ['最大操作数', '文字列をソート', 'パターンを検索'],
  },
  alg52: {
    text: 'フィボナッチ数列とは？',
    correct: '各数が前の2つの和',
    wrong: ['各数が積', '素数', '偶数'],
  },
  alg53: {
    text: '単純再帰フィボナッチの計算量は？',
    correct: 'O(2^n)',
    wrong: ['O(n)', 'O(n²)', 'O(log n)'],
  },
  alg54: {
    text: '動的計画法フィボナッチの計算量は？',
    correct: 'O(n)',
    wrong: ['O(2^n)', 'O(n²)', 'O(log n)'],
  },
  alg55: {
    text: 'カデインのアルゴリズムとは？',
    correct: '最大部分配列和を求める',
    wrong: ['配列をソート', '要素を検索', '最小値を見つける'],
  },
  alg56: {
    text: 'コイン両替問題とは？',
    correct: '最小枚数で両替',
    wrong: ['最大枚数', 'コインをソート', 'コインを数える'],
  },
  alg57: {
    text: '巡回セールスマン問題（TSP）とは？',
    correct: '全都市を訪問する最短経路',
    wrong: ['最長経路', '1都市を訪問', '都市をソート'],
  },
  alg58: {
    text: 'TSPの総当たり計算量は？',
    correct: 'O(n!)',
    wrong: ['O(n)', 'O(n²)', 'O(2^n)'],
  },
  alg59: {
    text: 'Nクイーン問題とは？',
    correct: 'N個のクイーンを攻撃なしに配置',
    wrong: ['クイーンを動かす', 'クイーンを数える', 'クイーンをソート'],
  },
  alg60: {
    text: '数独問題とは？',
    correct: '制約付きでグリッドを埋める',
    wrong: ['グリッドを空にする', '数字をソート', '数字を足す'],
  },
  alg61: {
    text: 'セグメント木とは？',
    correct: '範囲クエリ用のデータ構造',
    wrong: ['単純な二分木', '連結リスト', 'ハッシュテーブル'],
  },
  alg62: {
    text: 'フェニック木（BIT）とは？',
    correct: '接頭辞和用のデータ構造',
    wrong: ['二分探索木', 'ヒープ', 'グラフ'],
  },
  alg63: {
    text: 'トライとは？',
    correct: '文字列を格納する木構造',
    wrong: ['二分木', 'ヒープ', 'グラフ'],
  },
  alg64: {
    text: 'KMPアルゴリズムとは？',
    correct: '効率的なパターン検索',
    wrong: ['ソート', '二分探索', 'グラフ走査'],
  },
  alg65: {
    text: 'ラビンカープアルゴリズムとは？',
    correct: 'ハッシュを使ったパターン検索',
    wrong: ['ソート', '二分探索', 'グラフ走査'],
  },
  alg66: {
    text: 'Union-Findとは？',
    correct: '素集合用のデータ構造',
    wrong: ['二分木', 'ハッシュテーブル', '優先度キュー'],
  },
  alg67: {
    text: 'Union-Findの経路圧縮とは？',
    correct: '検索時に木を平坦化',
    wrong: ['木を深くする', 'ノードを削除', 'ノードを追加'],
  },
  alg68: {
    text: 'ランクによる結合とは？',
    correct: '小さい木を大きい木に結合',
    wrong: ['ランダムに結合', '常に左に結合', '常に右に結合'],
  },
  alg69: {
    text: 'A*アルゴリズムとは？',
    correct: 'ヒューリスティック付き経路探索',
    wrong: ['ヒューリスティックなし探索', 'ソート', '二分探索'],
  },
  alg70: {
    text: '許容的ヒューリスティックとは？',
    correct: '実際のコストを過大評価しない',
    wrong: ['常に過大評価', '正確なコスト', 'ランダムなコスト'],
  },
  alg71: {
    text: '最大フローアルゴリズムとは？',
    correct: 'ネットワークの最大フローを求める',
    wrong: ['最小フローを求める', 'フローをソート', 'フローを削除'],
  },
  alg72: {
    text: 'フォードファルカーソン法とは？',
    correct: '増加パスで最大フローを求める',
    wrong: ['最短経路を求める', '最小全域木', 'トポロジカルソート'],
  },
  alg73: {
    text: '最小カット最大フロー定理とは？',
    correct: '最大フローは最小カットに等しい',
    wrong: [
      '最大フローは最小カットより大きい',
      '関係なし',
      '最小フローは最大カットに等しい',
    ],
  },
  alg74: {
    text: '二部マッチングとは？',
    correct: '2つの集合の頂点をマッチング',
    wrong: ['任意の頂点をマッチング', '頂点をソート', '頂点を削除'],
  },
  alg75: {
    text: 'ハンガリアン法とは？',
    correct: '最小コストマッチング',
    wrong: ['最大コストマッチング', 'ソート', '検索'],
  },

  // ===== レベル7-8: 伝説/教授 =====
  alg76: {
    text: '償却計算量とは？',
    correct: '操作列の平均コスト',
    wrong: ['常に最悪ケース', '常に最良ケース', 'ランダムケース'],
  },
  alg77: {
    text: '競合分析とは？',
    correct: 'オンラインアルゴリズムとオフライン最適を比較',
    wrong: ['2つのオンラインアルゴリズムを比較', '計算量分析', '空間分析'],
  },
  alg78: {
    text: '乱択アルゴリズムとは？',
    correct: 'ランダムな決定を使用',
    wrong: ['常に決定的', 'ランダム性を使わない', 'ソートのみ'],
  },
  alg79: {
    text: 'ラスベガス vs モンテカルロとは？',
    correct: '常に正しい vs 確率的に正しい',
    wrong: ['両方常に正しい', '両方確率的に正しい', '違いなし'],
  },
  alg80: {
    text: 'クイックセレクトとは？',
    correct: 'k番目の要素を期待O(n)で見つける',
    wrong: ['配列全体をソート', '二分探索', '最大値を見つける'],
  },
  alg81: {
    text: '中央値の中央値問題とは？',
    correct: '保証O(n)での選択',
    wrong: ['O(n log n)での選択', 'ソート', '検索'],
  },
  alg82: {
    text: '接尾辞木とは？',
    correct: '文字列の全接尾辞の構造',
    wrong: ['二分木', '単純なトライ', 'グラフ'],
  },
  alg83: {
    text: 'ウッコネンのアルゴリズムとは？',
    correct: '線形時間で接尾辞木を構築',
    wrong: ['二乗時間で構築', 'パターン検索', 'ソート'],
  },
  alg84: {
    text: '接尾辞配列とは？',
    correct: '接尾辞のソート済み配列',
    wrong: ['接頭辞の配列', '接尾辞木', 'ハッシュテーブル'],
  },
  alg85: {
    text: 'LCP配列とは？',
    correct: '隣接接尾辞間の最長共通接頭辞',
    wrong: ['最長共通接尾辞', '最長部分文字列', '最長部分列'],
  },
  alg86: {
    text: 'マナカーのアルゴリズムとは？',
    correct: '線形時間で全回文を見つける',
    wrong: ['二乗時間で見つける', '回文をソート', '回文を数える'],
  },
  alg87: {
    text: 'Zアルゴリズムとは？',
    correct: 'パターンマッチング用Z配列を計算',
    wrong: ['ソート', '二分探索', 'グラフ走査'],
  },
  alg88: {
    text: 'エイホコラシックアルゴリズムとは？',
    correct: '複数パターン検索',
    wrong: ['単一パターン検索', 'ソート', 'グラフ走査'],
  },
  alg89: {
    text: '平方分割とは？',
    correct: 'サイズ√nのブロックに分割',
    wrong: ['半分に分割', '分割しない', 'n個に分割'],
  },
  alg90: {
    text: 'Moのアルゴリズムとは？',
    correct: 'オフライン範囲クエリに回答',
    wrong: ['オンラインクエリ', 'ソート', '検索'],
  },
  alg91: {
    text: 'Heavy-Light分解とは？',
    correct: '木をチェーンに分解',
    wrong: ['ノードに分解', '分解しない', '葉に分解'],
  },
  alg92: {
    text: '木の重心とは？',
    correct: '最大部分木を最小化するノード',
    wrong: ['木の根', '木の葉', 'ランダムなノード'],
  },
  alg93: {
    text: '重心分解とは？',
    correct: '重心で木を再帰的に分割',
    wrong: ['根で分割', '分割しない', '葉で分割'],
  },
  alg94: {
    text: '最小共通祖先（LCA）とは？',
    correct: '最も深い共通の祖先',
    wrong: ['最も高い祖先', '共通の子孫', '共通の兄弟'],
  },
  alg95: {
    text: 'LCAのバイナリリフティングとは？',
    correct: '2の累乗の祖先を前処理',
    wrong: ['線形に検索', 'BFSを使用', '単純なDFSを使用'],
  },
  alg96: {
    text: 'LCAのタージャンアルゴリズムとは？',
    correct: 'Union-Findでオフラインでのみ',
    wrong: ['オンラインLCA', 'ソート', '検索'],
  },
  alg97: {
    text: '強連結成分とは？',
    correct: '全ペアが到達可能な部分グラフ',
    wrong: ['非連結部分グラフ', '木', '単純サイクル'],
  },
  alg98: {
    text: 'コサラジュのアルゴリズムとは？',
    correct: '強連結成分を見つける',
    wrong: ['最短経路を見つける', 'トポロジカルソート', '全域木'],
  },
  alg99: {
    text: 'SCCのタージャンアルゴリズムとは？',
    correct: '1回のDFSでSCCを求める',
    wrong: ['2回のパスでSCC', 'BFSを使用', 'ソートを使用'],
  },
  alg100: {
    text: '関節点とは？',
    correct: '削除するとグラフが非連結になる頂点',
    wrong: ['接続する頂点', '重要な辺', 'サイクル'],
  },
};

export default algorithms;
